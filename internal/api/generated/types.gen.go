// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AgentEventType.
const (
	AgentEventTypeConnected  AgentEventType = "connected"
	AgentEventTypeDone       AgentEventType = "done"
	AgentEventTypeError      AgentEventType = "error"
	AgentEventTypeResult     AgentEventType = "result"
	AgentEventTypeStatus     AgentEventType = "status"
	AgentEventTypeThinking   AgentEventType = "thinking"
	AgentEventTypeToolCall   AgentEventType = "tool_call"
	AgentEventTypeToolResult AgentEventType = "tool_result"
)

// Defines values for FileType.
const (
	Document FileType = "document"
	Invoice  FileType = "invoice"
	Music    FileType = "music"
	Photo    FileType = "photo"
	Video    FileType = "video"
)

// Defines values for ProcessingStatus.
const (
	Completed  ProcessingStatus = "completed"
	Failed     ProcessingStatus = "failed"
	Pending    ProcessingStatus = "pending"
	Processing ProcessingStatus = "processing"
)

// Defines values for ListFilesParamsSortBy.
const (
	CreatedAt ListFilesParamsSortBy = "created_at"
	Size      ListFilesParamsSortBy = "size"
	Title     ListFilesParamsSortBy = "title"
	UpdatedAt ListFilesParamsSortBy = "updated_at"
)

// Defines values for ListFilesParamsSortOrder.
const (
	Asc  ListFilesParamsSortOrder = "asc"
	Desc ListFilesParamsSortOrder = "desc"
)

// Defines values for SearchFilesParamsType.
const (
	Fulltext SearchFilesParamsType = "fulltext"
	Hybrid   SearchFilesParamsType = "hybrid"
	Semantic SearchFilesParamsType = "semantic"
)

// AgentEvent defines model for AgentEvent.
type AgentEvent struct {
	Data    *map[string]interface{} `json:"data,omitempty"`
	FileId  *int                    `json:"file_id,omitempty"`
	Message string                  `json:"message"`
	Tool    *string                 `json:"tool,omitempty"`
	Type    AgentEventType          `json:"type"`
}

// AgentEventType defines model for AgentEvent.Type.
type AgentEventType string

// AgentStatusResponse defines model for AgentStatusResponse.
type AgentStatusResponse struct {
	Enabled bool `json:"enabled"`
}

// BatchDownloadRequest defines model for BatchDownloadRequest.
type BatchDownloadRequest struct {
	// FileIds Array of file IDs to download
	FileIds []int `json:"file_ids"`
}

// CreateFileRequest defines model for CreateFileRequest.
type CreateFileRequest struct {
	FileType         *FileType `json:"file_type,omitempty"`
	FolderId         *int      `json:"folder_id"`
	MimeType         *string   `json:"mime_type,omitempty"`
	OriginalFilename string    `json:"original_filename"`
	S3Key            string    `json:"s3_key"`
	Size             *int64    `json:"size,omitempty"`
	Title            string    `json:"title"`
}

// CreateFolderRequest defines model for CreateFolderRequest.
type CreateFolderRequest struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
	ParentId    *int    `json:"parent_id"`
}

// CreateTagRequest defines model for CreateTagRequest.
type CreateTagRequest struct {
	Color       *string `json:"color,omitempty"`
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// File defines model for File.
type File struct {
	// Content Parsed text content
	Content      *string   `json:"content,omitempty"`
	CreatedAt    time.Time `json:"created_at"`
	FileType     FileType  `json:"file_type"`
	Folder       *Folder   `json:"folder,omitempty"`
	FolderId     *int      `json:"folder_id"`
	HasEmbedding bool      `json:"has_embedding"`
	Id           int       `json:"id"`

	// InvoiceId External invoice system ID (only set for invoice file types)
	InvoiceId        *int             `json:"invoice_id"`
	MimeType         *string          `json:"mime_type,omitempty"`
	OriginalFilename string           `json:"original_filename"`
	ProcessingError  *string          `json:"processing_error,omitempty"`
	ProcessingStatus ProcessingStatus `json:"processing_status"`
	S3Key            string           `json:"s3_key"`
	Size             *int64           `json:"size,omitempty"`
	Summary          *string          `json:"summary,omitempty"`
	Tags             *[]Tag           `json:"tags,omitempty"`
	Title            string           `json:"title"`
	UpdatedAt        time.Time        `json:"updated_at"`
	UserId           string           `json:"user_id"`
}

// FileDownloadResponse defines model for FileDownloadResponse.
type FileDownloadResponse struct {
	DownloadUrl string    `json:"download_url"`
	ExpiresAt   time.Time `json:"expires_at"`
	Filename    string    `json:"filename"`
	Key         string    `json:"key"`
}

// FileListResponse defines model for FileListResponse.
type FileListResponse struct {
	Data   []File `json:"data"`
	Limit  int    `json:"limit"`
	Offset int    `json:"offset"`
	Total  int    `json:"total"`
}

// FileType defines model for FileType.
type FileType string

// Folder defines model for Folder.
type Folder struct {
	Children    *[]Folder `json:"children,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          int       `json:"id"`
	Name        string    `json:"name"`
	ParentId    *int      `json:"parent_id"`
	Tags        *[]Tag    `json:"tags,omitempty"`
	UpdatedAt   time.Time `json:"updated_at"`
	UserId      string    `json:"user_id"`
}

// FolderListResponse defines model for FolderListResponse.
type FolderListResponse struct {
	Data   []Folder `json:"data"`
	Limit  int      `json:"limit"`
	Offset int      `json:"offset"`
	Total  int      `json:"total"`
}

// FolderTree defines model for FolderTree.
type FolderTree struct {
	Children *[]FolderTree `json:"children,omitempty"`
	Id       int           `json:"id"`
	Name     string        `json:"name"`
	ParentId *int          `json:"parent_id"`
}

// MoveFilesRequest defines model for MoveFilesRequest.
type MoveFilesRequest struct {
	FileIds []int `json:"file_ids"`

	// FolderId Target folder ID (null for root)
	FolderId *int `json:"folder_id"`
}

// MoveFolderRequest defines model for MoveFolderRequest.
type MoveFolderRequest struct {
	// ParentId New parent folder ID (null for root)
	ParentId *int `json:"parent_id"`
}

// OrganizeFileResult defines model for OrganizeFileResult.
type OrganizeFileResult struct {
	FileId  int    `json:"file_id"`
	Message string `json:"message"`

	// StreamUrl URL to subscribe to SSE stream for progress updates
	StreamUrl string `json:"stream_url"`
}

// PresignedURLResponse defines model for PresignedURLResponse.
type PresignedURLResponse struct {
	ContentType string `json:"content_type"`
	Key         string `json:"key"`
	UploadUrl   string `json:"upload_url"`
}

// ProcessingStatus defines model for ProcessingStatus.
type ProcessingStatus string

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	Data       []SearchResult `json:"data"`
	Query      string         `json:"query"`
	SearchType string         `json:"search_type"`
	Total      int            `json:"total"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	File    File    `json:"file"`
	Score   float64 `json:"score"`
	Snippet *string `json:"snippet,omitempty"`
}

// Tag defines model for Tag.
type Tag struct {
	// Color Hex color code (e.g.,
	Color       *string   `json:"color,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          int       `json:"id"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
	UserId      string    `json:"user_id"`
}

// TagIdsRequest defines model for TagIdsRequest.
type TagIdsRequest struct {
	TagIds []int `json:"tag_ids"`
}

// TagListResponse defines model for TagListResponse.
type TagListResponse struct {
	Data   []Tag `json:"data"`
	Limit  int   `json:"limit"`
	Offset int   `json:"offset"`
	Total  int   `json:"total"`
}

// UpdateFileRequest defines model for UpdateFileRequest.
type UpdateFileRequest struct {
	FileType *FileType `json:"file_type,omitempty"`
	FolderId *int      `json:"folder_id"`
	Summary  *string   `json:"summary,omitempty"`
	Title    *string   `json:"title,omitempty"`
}

// UpdateFolderRequest defines model for UpdateFolderRequest.
type UpdateFolderRequest struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// UpdateTagRequest defines model for UpdateTagRequest.
type UpdateTagRequest struct {
	Color       *string `json:"color,omitempty"`
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// UploadResponse defines model for UploadResponse.
type UploadResponse struct {
	ContentType string  `json:"content_type"`
	DownloadUrl *string `json:"download_url,omitempty"`
	Filename    string  `json:"filename"`

	// Key S3 object key
	Key  string `json:"key"`
	Size int    `json:"size"`
}

// FileId defines model for FileId.
type FileId = int

// FolderId defines model for FolderId.
type FolderId = int

// Limit defines model for Limit.
type Limit = int

// Offset defines model for Offset.
type Offset = int

// TagId defines model for TagId.
type TagId = int

// BadRequest defines model for BadRequest.
type BadRequest = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// ListFilesParams defines parameters for ListFiles.
type ListFilesParams struct {
	// Keyword Search keyword for title, summary, or content
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// FolderId Filter by folder ID
	FolderId *int `form:"folder_id,omitempty" json:"folder_id,omitempty"`

	// AllFolders When true, search across all folders (ignores folder_id). Useful for tag filtering.
	AllFolders *bool `form:"all_folders,omitempty" json:"all_folders,omitempty"`

	// FileType Filter by file type
	FileType *FileType `form:"file_type,omitempty" json:"file_type,omitempty"`

	// TagIds Filter by tag IDs (comma-separated)
	TagIds *string `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`

	// Status Filter by processing status
	Status *ProcessingStatus `form:"status,omitempty" json:"status,omitempty"`

	// SortBy Field to sort by
	SortBy *ListFilesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortOrder Sort order
	SortOrder *ListFilesParamsSortOrder `form:"sort_order,omitempty" json:"sort_order,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListFilesParamsSortBy defines parameters for ListFiles.
type ListFilesParamsSortBy string

// ListFilesParamsSortOrder defines parameters for ListFiles.
type ListFilesParamsSortOrder string

// UnlinkFileInvoiceParams defines parameters for UnlinkFileInvoice.
type UnlinkFileInvoiceParams struct {
	// InvoiceId The invoice ID to unlink
	InvoiceId int64 `form:"invoice_id" json:"invoice_id"`
}

// ListFoldersParams defines parameters for ListFolders.
type ListFoldersParams struct {
	// Keyword Search keyword for folder name
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// ParentId Filter by parent folder ID (omit for root folders)
	ParentId *int `form:"parent_id,omitempty" json:"parent_id,omitempty"`

	// TagIds Filter by tag IDs (comma-separated)
	TagIds *string `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetFolderTreeParams defines parameters for GetFolderTree.
type GetFolderTreeParams struct {
	// ParentId Start from this parent folder (omit for full tree from root)
	ParentId *int `form:"parent_id,omitempty" json:"parent_id,omitempty"`
}

// SearchFilesParams defines parameters for SearchFiles.
type SearchFilesParams struct {
	// Q Search query
	Q string `form:"q" json:"q"`

	// Type Search type
	Type *SearchFilesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// FolderId Limit search to a folder
	FolderId *int `form:"folder_id,omitempty" json:"folder_id,omitempty"`

	// FileType Filter by file type
	FileType *FileType `form:"file_type,omitempty" json:"file_type,omitempty"`

	// TagIds Filter by tag IDs (comma-separated)
	TagIds *string `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// SearchFilesParamsType defines parameters for SearchFiles.
type SearchFilesParamsType string

// ListTagsParams defines parameters for ListTags.
type ListTagsParams struct {
	// Keyword Search keyword for tag name
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// UploadFileMultipartBody defines parameters for UploadFile.
type UploadFileMultipartBody struct {
	// File File to upload
	File openapi_types.File `json:"file"`
}

// GetPresignedURLParams defines parameters for GetPresignedURL.
type GetPresignedURLParams struct {
	// Filename Name of the file to upload
	Filename string `form:"filename" json:"filename"`

	// ContentType MIME type of the file
	ContentType *string `form:"content_type,omitempty" json:"content_type,omitempty"`
}

// CreateFileJSONRequestBody defines body for CreateFile for application/json ContentType.
type CreateFileJSONRequestBody = CreateFileRequest

// BatchDownloadFilesJSONRequestBody defines body for BatchDownloadFiles for application/json ContentType.
type BatchDownloadFilesJSONRequestBody = BatchDownloadRequest

// MoveFilesJSONRequestBody defines body for MoveFiles for application/json ContentType.
type MoveFilesJSONRequestBody = MoveFilesRequest

// UpdateFileJSONRequestBody defines body for UpdateFile for application/json ContentType.
type UpdateFileJSONRequestBody = UpdateFileRequest

// RemoveTagsFromFileJSONRequestBody defines body for RemoveTagsFromFile for application/json ContentType.
type RemoveTagsFromFileJSONRequestBody = TagIdsRequest

// AddTagsToFileJSONRequestBody defines body for AddTagsToFile for application/json ContentType.
type AddTagsToFileJSONRequestBody = TagIdsRequest

// CreateFolderJSONRequestBody defines body for CreateFolder for application/json ContentType.
type CreateFolderJSONRequestBody = CreateFolderRequest

// UpdateFolderJSONRequestBody defines body for UpdateFolder for application/json ContentType.
type UpdateFolderJSONRequestBody = UpdateFolderRequest

// MoveFolderJSONRequestBody defines body for MoveFolder for application/json ContentType.
type MoveFolderJSONRequestBody = MoveFolderRequest

// RemoveTagsFromFolderJSONRequestBody defines body for RemoveTagsFromFolder for application/json ContentType.
type RemoveTagsFromFolderJSONRequestBody = TagIdsRequest

// AddTagsToFolderJSONRequestBody defines body for AddTagsToFolder for application/json ContentType.
type AddTagsToFolderJSONRequestBody = TagIdsRequest

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = CreateTagRequest

// UpdateTagJSONRequestBody defines body for UpdateTag for application/json ContentType.
type UpdateTagJSONRequestBody = UpdateTagRequest

// UploadFileMultipartRequestBody defines body for UploadFile for multipart/form-data ContentType.
type UploadFileMultipartRequestBody UploadFileMultipartBody

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
