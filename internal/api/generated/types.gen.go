// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AgentEventType.
const (
	AgentEventTypeConnected  AgentEventType = "connected"
	AgentEventTypeDone       AgentEventType = "done"
	AgentEventTypeError      AgentEventType = "error"
	AgentEventTypeResult     AgentEventType = "result"
	AgentEventTypeStatus     AgentEventType = "status"
	AgentEventTypeThinking   AgentEventType = "thinking"
	AgentEventTypeToolCall   AgentEventType = "tool_call"
	AgentEventTypeToolResult AgentEventType = "tool_result"
)

// Defines values for FileType.
const (
	Document FileType = "document"
	Invoice  FileType = "invoice"
	Music    FileType = "music"
	Photo    FileType = "photo"
	Video    FileType = "video"
)

// Defines values for ProcessingStatus.
const (
	Completed  ProcessingStatus = "completed"
	Failed     ProcessingStatus = "failed"
	Pending    ProcessingStatus = "pending"
	Processing ProcessingStatus = "processing"
)

// Defines values for ListFilesParamsSortBy.
const (
	CreatedAt ListFilesParamsSortBy = "created_at"
	Size      ListFilesParamsSortBy = "size"
	Title     ListFilesParamsSortBy = "title"
	UpdatedAt ListFilesParamsSortBy = "updated_at"
)

// Defines values for ListFilesParamsSortOrder.
const (
	Asc  ListFilesParamsSortOrder = "asc"
	Desc ListFilesParamsSortOrder = "desc"
)

// Defines values for SearchFilesParamsType.
const (
	Fulltext SearchFilesParamsType = "fulltext"
	Hybrid   SearchFilesParamsType = "hybrid"
	Semantic SearchFilesParamsType = "semantic"
)

// AgentEvent defines model for AgentEvent.
type AgentEvent struct {
	Data    *map[string]interface{} `json:"data,omitempty"`
	FileId  *int                    `json:"file_id,omitempty"`
	Message string                  `json:"message"`
	Tool    *string                 `json:"tool,omitempty"`
	Type    AgentEventType          `json:"type"`
}

// AgentEventType defines model for AgentEvent.Type.
type AgentEventType string

// AgentStatusResponse defines model for AgentStatusResponse.
type AgentStatusResponse struct {
	Enabled bool `json:"enabled"`
}

// BatchDownloadRequest defines model for BatchDownloadRequest.
type BatchDownloadRequest struct {
	// FileIds Array of file IDs to download
	FileIds []int `json:"file_ids"`
}

// CreateFileRequest defines model for CreateFileRequest.
type CreateFileRequest struct {
	FileType         *FileType `json:"file_type,omitempty"`
	FolderId         *int      `json:"folder_id"`
	MimeType         *string   `json:"mime_type,omitempty"`
	OriginalFilename string    `json:"original_filename"`
	S3Key            string    `json:"s3_key"`
	Size             *int64    `json:"size,omitempty"`
	Title            string    `json:"title"`
}

// CreateFolderRequest defines model for CreateFolderRequest.
type CreateFolderRequest struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
	ParentId    *int    `json:"parent_id"`
}

// CreateTagRequest defines model for CreateTagRequest.
type CreateTagRequest struct {
	Color       *string `json:"color,omitempty"`
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// File defines model for File.
type File struct {
	// Content Parsed text content
	Content          *string          `json:"content,omitempty"`
	CreatedAt        time.Time        `json:"created_at"`
	FileType         FileType         `json:"file_type"`
	Folder           *Folder          `json:"folder,omitempty"`
	FolderId         *int             `json:"folder_id"`
	HasEmbedding     bool             `json:"has_embedding"`
	Id               int              `json:"id"`
	MimeType         *string          `json:"mime_type,omitempty"`
	OriginalFilename string           `json:"original_filename"`
	ProcessingError  *string          `json:"processing_error,omitempty"`
	ProcessingStatus ProcessingStatus `json:"processing_status"`
	S3Key            string           `json:"s3_key"`
	Size             *int64           `json:"size,omitempty"`
	Summary          *string          `json:"summary,omitempty"`
	Tags             *[]Tag           `json:"tags,omitempty"`
	Title            string           `json:"title"`
	UpdatedAt        time.Time        `json:"updated_at"`
	UserId           string           `json:"user_id"`
}

// FileDownloadResponse defines model for FileDownloadResponse.
type FileDownloadResponse struct {
	DownloadUrl string    `json:"download_url"`
	ExpiresAt   time.Time `json:"expires_at"`
	Filename    string    `json:"filename"`
	Key         string    `json:"key"`
}

// FileListResponse defines model for FileListResponse.
type FileListResponse struct {
	Data   []File `json:"data"`
	Limit  int    `json:"limit"`
	Offset int    `json:"offset"`
	Total  int    `json:"total"`
}

// FileType defines model for FileType.
type FileType string

// Folder defines model for Folder.
type Folder struct {
	Children    *[]Folder `json:"children,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          int       `json:"id"`
	Name        string    `json:"name"`
	ParentId    *int      `json:"parent_id"`
	Tags        *[]Tag    `json:"tags,omitempty"`
	UpdatedAt   time.Time `json:"updated_at"`
	UserId      string    `json:"user_id"`
}

// FolderListResponse defines model for FolderListResponse.
type FolderListResponse struct {
	Data   []Folder `json:"data"`
	Limit  int      `json:"limit"`
	Offset int      `json:"offset"`
	Total  int      `json:"total"`
}

// FolderTree defines model for FolderTree.
type FolderTree struct {
	Children *[]FolderTree `json:"children,omitempty"`
	Id       int           `json:"id"`
	Name     string        `json:"name"`
	ParentId *int          `json:"parent_id"`
}

// MoveFilesRequest defines model for MoveFilesRequest.
type MoveFilesRequest struct {
	FileIds []int `json:"file_ids"`

	// FolderId Target folder ID (null for root)
	FolderId *int `json:"folder_id"`
}

// MoveFolderRequest defines model for MoveFolderRequest.
type MoveFolderRequest struct {
	// ParentId New parent folder ID (null for root)
	ParentId *int `json:"parent_id"`
}

// OrganizeFileResult defines model for OrganizeFileResult.
type OrganizeFileResult struct {
	FileId  int    `json:"file_id"`
	Message string `json:"message"`

	// StreamUrl URL to subscribe to SSE stream for progress updates
	StreamUrl string `json:"stream_url"`
}

// PresignedURLResponse defines model for PresignedURLResponse.
type PresignedURLResponse struct {
	ContentType string `json:"content_type"`
	Key         string `json:"key"`
	UploadUrl   string `json:"upload_url"`
}

// ProcessingStatus defines model for ProcessingStatus.
type ProcessingStatus string

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	Data       []SearchResult `json:"data"`
	Query      string         `json:"query"`
	SearchType string         `json:"search_type"`
	Total      int            `json:"total"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	File    File    `json:"file"`
	Score   float64 `json:"score"`
	Snippet *string `json:"snippet,omitempty"`
}

// Tag defines model for Tag.
type Tag struct {
	// Color Hex color code (e.g.,
	Color       *string   `json:"color,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          int       `json:"id"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
	UserId      string    `json:"user_id"`
}

// TagIdsRequest defines model for TagIdsRequest.
type TagIdsRequest struct {
	TagIds []int `json:"tag_ids"`
}

// TagListResponse defines model for TagListResponse.
type TagListResponse struct {
	Data   []Tag `json:"data"`
	Limit  int   `json:"limit"`
	Offset int   `json:"offset"`
	Total  int   `json:"total"`
}

// UpdateFileRequest defines model for UpdateFileRequest.
type UpdateFileRequest struct {
	FileType *FileType `json:"file_type,omitempty"`
	FolderId *int      `json:"folder_id"`
	Summary  *string   `json:"summary,omitempty"`
	Title    *string   `json:"title,omitempty"`
}

// UpdateFolderRequest defines model for UpdateFolderRequest.
type UpdateFolderRequest struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// UpdateTagRequest defines model for UpdateTagRequest.
type UpdateTagRequest struct {
	Color       *string `json:"color,omitempty"`
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// UploadResponse defines model for UploadResponse.
type UploadResponse struct {
	ContentType string  `json:"content_type"`
	DownloadUrl *string `json:"download_url,omitempty"`
	Filename    string  `json:"filename"`

	// Key S3 object key
	Key  string `json:"key"`
	Size int    `json:"size"`
}

// FileId defines model for FileId.
type FileId = int

// FolderId defines model for FolderId.
type FolderId = int

// Limit defines model for Limit.
type Limit = int

// Offset defines model for Offset.
type Offset = int

// TagId defines model for TagId.
type TagId = int

// BadRequest defines model for BadRequest.
type BadRequest = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// ListFilesParams defines parameters for ListFiles.
type ListFilesParams struct {
	// Keyword Search keyword for title, summary, or content
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// FolderId Filter by folder ID
	FolderId *int `form:"folder_id,omitempty" json:"folder_id,omitempty"`

	// AllFolders When true, search across all folders (ignores folder_id). Useful for tag filtering.
	AllFolders *bool `form:"all_folders,omitempty" json:"all_folders,omitempty"`

	// FileType Filter by file type
	FileType *FileType `form:"file_type,omitempty" json:"file_type,omitempty"`

	// TagIds Filter by tag IDs (comma-separated)
	TagIds *string `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`

	// Status Filter by processing status
	Status *ProcessingStatus `form:"status,omitempty" json:"status,omitempty"`

	// SortBy Field to sort by
	SortBy *ListFilesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortOrder Sort order
	SortOrder *ListFilesParamsSortOrder `form:"sort_order,omitempty" json:"sort_order,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListFilesParamsSortBy defines parameters for ListFiles.
type ListFilesParamsSortBy string

// ListFilesParamsSortOrder defines parameters for ListFiles.
type ListFilesParamsSortOrder string

// ListFoldersParams defines parameters for ListFolders.
type ListFoldersParams struct {
	// Keyword Search keyword for folder name
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// ParentId Filter by parent folder ID (omit for root folders)
	ParentId *int `form:"parent_id,omitempty" json:"parent_id,omitempty"`

	// TagIds Filter by tag IDs (comma-separated)
	TagIds *string `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetFolderTreeParams defines parameters for GetFolderTree.
type GetFolderTreeParams struct {
	// ParentId Start from this parent folder (omit for full tree from root)
	ParentId *int `form:"parent_id,omitempty" json:"parent_id,omitempty"`
}

// SearchFilesParams defines parameters for SearchFiles.
type SearchFilesParams struct {
	// Q Search query
	Q string `form:"q" json:"q"`

	// Type Search type
	Type *SearchFilesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// FolderId Limit search to a folder
	FolderId *int `form:"folder_id,omitempty" json:"folder_id,omitempty"`

	// FileType Filter by file type
	FileType *FileType `form:"file_type,omitempty" json:"file_type,omitempty"`

	// TagIds Filter by tag IDs (comma-separated)
	TagIds *string `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// SearchFilesParamsType defines parameters for SearchFiles.
type SearchFilesParamsType string

// ListTagsParams defines parameters for ListTags.
type ListTagsParams struct {
	// Keyword Search keyword for tag name
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// UploadFileMultipartBody defines parameters for UploadFile.
type UploadFileMultipartBody struct {
	// File File to upload
	File openapi_types.File `json:"file"`
}

// GetPresignedURLParams defines parameters for GetPresignedURL.
type GetPresignedURLParams struct {
	// Filename Name of the file to upload
	Filename string `form:"filename" json:"filename"`

	// ContentType MIME type of the file
	ContentType *string `form:"content_type,omitempty" json:"content_type,omitempty"`
}

// CreateFileJSONRequestBody defines body for CreateFile for application/json ContentType.
type CreateFileJSONRequestBody = CreateFileRequest

// BatchDownloadFilesJSONRequestBody defines body for BatchDownloadFiles for application/json ContentType.
type BatchDownloadFilesJSONRequestBody = BatchDownloadRequest

// MoveFilesJSONRequestBody defines body for MoveFiles for application/json ContentType.
type MoveFilesJSONRequestBody = MoveFilesRequest

// UpdateFileJSONRequestBody defines body for UpdateFile for application/json ContentType.
type UpdateFileJSONRequestBody = UpdateFileRequest

// RemoveTagsFromFileJSONRequestBody defines body for RemoveTagsFromFile for application/json ContentType.
type RemoveTagsFromFileJSONRequestBody = TagIdsRequest

// AddTagsToFileJSONRequestBody defines body for AddTagsToFile for application/json ContentType.
type AddTagsToFileJSONRequestBody = TagIdsRequest

// CreateFolderJSONRequestBody defines body for CreateFolder for application/json ContentType.
type CreateFolderJSONRequestBody = CreateFolderRequest

// UpdateFolderJSONRequestBody defines body for UpdateFolder for application/json ContentType.
type UpdateFolderJSONRequestBody = UpdateFolderRequest

// MoveFolderJSONRequestBody defines body for MoveFolder for application/json ContentType.
type MoveFolderJSONRequestBody = MoveFolderRequest

// RemoveTagsFromFolderJSONRequestBody defines body for RemoveTagsFromFolder for application/json ContentType.
type RemoveTagsFromFolderJSONRequestBody = TagIdsRequest

// AddTagsToFolderJSONRequestBody defines body for AddTagsToFolder for application/json ContentType.
type AddTagsToFolderJSONRequestBody = TagIdsRequest

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = CreateTagRequest

// UpdateTagJSONRequestBody defines body for UpdateTag for application/json ContentType.
type UpdateTagJSONRequestBody = UpdateTagRequest

// UploadFileMultipartRequestBody defines body for UploadFile for multipart/form-data ContentType.
type UploadFileMultipartRequestBody UploadFileMultipartBody

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
	"//8Jbd+txmgAAA==",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
