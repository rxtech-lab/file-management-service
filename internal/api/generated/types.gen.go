// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for AgentEventType.
const (
	AgentEventTypeConnected  AgentEventType = "connected"
	AgentEventTypeDone       AgentEventType = "done"
	AgentEventTypeError      AgentEventType = "error"
	AgentEventTypeResult     AgentEventType = "result"
	AgentEventTypeStatus     AgentEventType = "status"
	AgentEventTypeThinking   AgentEventType = "thinking"
	AgentEventTypeToolCall   AgentEventType = "tool_call"
	AgentEventTypeToolResult AgentEventType = "tool_result"
)

// Defines values for FileType.
const (
	Document FileType = "document"
	Invoice  FileType = "invoice"
	Music    FileType = "music"
	Photo    FileType = "photo"
	Video    FileType = "video"
)

// Defines values for ProcessingStatus.
const (
	Completed  ProcessingStatus = "completed"
	Failed     ProcessingStatus = "failed"
	Pending    ProcessingStatus = "pending"
	Processing ProcessingStatus = "processing"
)

// Defines values for ListFilesParamsSortBy.
const (
	CreatedAt ListFilesParamsSortBy = "created_at"
	Size      ListFilesParamsSortBy = "size"
	Title     ListFilesParamsSortBy = "title"
	UpdatedAt ListFilesParamsSortBy = "updated_at"
)

// Defines values for ListFilesParamsSortOrder.
const (
	Asc  ListFilesParamsSortOrder = "asc"
	Desc ListFilesParamsSortOrder = "desc"
)

// Defines values for SearchFilesParamsType.
const (
	Fulltext SearchFilesParamsType = "fulltext"
	Hybrid   SearchFilesParamsType = "hybrid"
	Semantic SearchFilesParamsType = "semantic"
)

// AgentEvent defines model for AgentEvent.
type AgentEvent struct {
	Data    *map[string]interface{} `json:"data,omitempty"`
	FileId  *int                    `json:"file_id,omitempty"`
	Message string                  `json:"message"`
	Tool    *string                 `json:"tool,omitempty"`
	Type    AgentEventType          `json:"type"`
}

// AgentEventType defines model for AgentEvent.Type.
type AgentEventType string

// AgentStatusResponse defines model for AgentStatusResponse.
type AgentStatusResponse struct {
	Enabled bool `json:"enabled"`
}

// BatchDownloadRequest defines model for BatchDownloadRequest.
type BatchDownloadRequest struct {
	// FileIds Array of file IDs to download
	FileIds []int `json:"file_ids"`
}

// CreateFileRequest defines model for CreateFileRequest.
type CreateFileRequest struct {
	FileType         *FileType `json:"file_type,omitempty"`
	FolderId         *int      `json:"folder_id"`
	MimeType         *string   `json:"mime_type,omitempty"`
	OriginalFilename string    `json:"original_filename"`
	S3Key            string    `json:"s3_key"`
	Size             *int64    `json:"size,omitempty"`
	Title            string    `json:"title"`
}

// CreateFolderRequest defines model for CreateFolderRequest.
type CreateFolderRequest struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
	ParentId    *int    `json:"parent_id"`
}

// CreateTagRequest defines model for CreateTagRequest.
type CreateTagRequest struct {
	Color       *string `json:"color,omitempty"`
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// File defines model for File.
type File struct {
	// Content Parsed text content
	Content      *string   `json:"content,omitempty"`
	CreatedAt    time.Time `json:"created_at"`
	FileType     FileType  `json:"file_type"`
	Folder       *Folder   `json:"folder,omitempty"`
	FolderId     *int      `json:"folder_id"`
	HasEmbedding bool      `json:"has_embedding"`
	Id           int       `json:"id"`

	// InvoiceId External invoice system ID (only set for invoice file types)
	InvoiceId        *int             `json:"invoice_id"`
	MimeType         *string          `json:"mime_type,omitempty"`
	OriginalFilename string           `json:"original_filename"`
	ProcessingError  *string          `json:"processing_error,omitempty"`
	ProcessingStatus ProcessingStatus `json:"processing_status"`
	S3Key            string           `json:"s3_key"`
	Size             *int64           `json:"size,omitempty"`
	Summary          *string          `json:"summary,omitempty"`
	Tags             *[]Tag           `json:"tags,omitempty"`
	Title            string           `json:"title"`
	UpdatedAt        time.Time        `json:"updated_at"`
	UserId           string           `json:"user_id"`
}

// FileDownloadResponse defines model for FileDownloadResponse.
type FileDownloadResponse struct {
	DownloadUrl string    `json:"download_url"`
	ExpiresAt   time.Time `json:"expires_at"`
	Filename    string    `json:"filename"`
	Key         string    `json:"key"`
}

// FileListResponse defines model for FileListResponse.
type FileListResponse struct {
	Data   []File `json:"data"`
	Limit  int    `json:"limit"`
	Offset int    `json:"offset"`
	Total  int    `json:"total"`
}

// FileType defines model for FileType.
type FileType string

// Folder defines model for Folder.
type Folder struct {
	Children    *[]Folder `json:"children,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          int       `json:"id"`
	Name        string    `json:"name"`
	ParentId    *int      `json:"parent_id"`
	Tags        *[]Tag    `json:"tags,omitempty"`
	UpdatedAt   time.Time `json:"updated_at"`
	UserId      string    `json:"user_id"`
}

// FolderListResponse defines model for FolderListResponse.
type FolderListResponse struct {
	Data   []Folder `json:"data"`
	Limit  int      `json:"limit"`
	Offset int      `json:"offset"`
	Total  int      `json:"total"`
}

// FolderTree defines model for FolderTree.
type FolderTree struct {
	Children *[]FolderTree `json:"children,omitempty"`
	Id       int           `json:"id"`
	Name     string        `json:"name"`
	ParentId *int          `json:"parent_id"`
}

// MoveFilesRequest defines model for MoveFilesRequest.
type MoveFilesRequest struct {
	FileIds []int `json:"file_ids"`

	// FolderId Target folder ID (null for root)
	FolderId *int `json:"folder_id"`
}

// MoveFolderRequest defines model for MoveFolderRequest.
type MoveFolderRequest struct {
	// ParentId New parent folder ID (null for root)
	ParentId *int `json:"parent_id"`
}

// OrganizeFileResult defines model for OrganizeFileResult.
type OrganizeFileResult struct {
	FileId  int    `json:"file_id"`
	Message string `json:"message"`

	// StreamUrl URL to subscribe to SSE stream for progress updates
	StreamUrl string `json:"stream_url"`
}

// PresignedURLResponse defines model for PresignedURLResponse.
type PresignedURLResponse struct {
	ContentType string `json:"content_type"`
	Key         string `json:"key"`
	UploadUrl   string `json:"upload_url"`
}

// ProcessingStatus defines model for ProcessingStatus.
type ProcessingStatus string

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	Data       []SearchResult `json:"data"`
	Query      string         `json:"query"`
	SearchType string         `json:"search_type"`
	Total      int            `json:"total"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	File    File    `json:"file"`
	Score   float64 `json:"score"`
	Snippet *string `json:"snippet,omitempty"`
}

// Tag defines model for Tag.
type Tag struct {
	// Color Hex color code (e.g.,
	Color       *string   `json:"color,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          int       `json:"id"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
	UserId      string    `json:"user_id"`
}

// TagIdsRequest defines model for TagIdsRequest.
type TagIdsRequest struct {
	TagIds []int `json:"tag_ids"`
}

// TagListResponse defines model for TagListResponse.
type TagListResponse struct {
	Data   []Tag `json:"data"`
	Limit  int   `json:"limit"`
	Offset int   `json:"offset"`
	Total  int   `json:"total"`
}

// UpdateFileRequest defines model for UpdateFileRequest.
type UpdateFileRequest struct {
	FileType *FileType `json:"file_type,omitempty"`
	FolderId *int      `json:"folder_id"`
	Summary  *string   `json:"summary,omitempty"`
	Title    *string   `json:"title,omitempty"`
}

// UpdateFolderRequest defines model for UpdateFolderRequest.
type UpdateFolderRequest struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// UpdateTagRequest defines model for UpdateTagRequest.
type UpdateTagRequest struct {
	Color       *string `json:"color,omitempty"`
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// UploadResponse defines model for UploadResponse.
type UploadResponse struct {
	ContentType string  `json:"content_type"`
	DownloadUrl *string `json:"download_url,omitempty"`
	Filename    string  `json:"filename"`

	// Key S3 object key
	Key  string `json:"key"`
	Size int    `json:"size"`
}

// FileId defines model for FileId.
type FileId = int

// FolderId defines model for FolderId.
type FolderId = int

// Limit defines model for Limit.
type Limit = int

// Offset defines model for Offset.
type Offset = int

// TagId defines model for TagId.
type TagId = int

// BadRequest defines model for BadRequest.
type BadRequest = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// ListFilesParams defines parameters for ListFiles.
type ListFilesParams struct {
	// Keyword Search keyword for title, summary, or content
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// FolderId Filter by folder ID
	FolderId *int `form:"folder_id,omitempty" json:"folder_id,omitempty"`

	// AllFolders When true, search across all folders (ignores folder_id). Useful for tag filtering.
	AllFolders *bool `form:"all_folders,omitempty" json:"all_folders,omitempty"`

	// FileType Filter by file type
	FileType *FileType `form:"file_type,omitempty" json:"file_type,omitempty"`

	// TagIds Filter by tag IDs (comma-separated)
	TagIds *string `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`

	// Status Filter by processing status
	Status *ProcessingStatus `form:"status,omitempty" json:"status,omitempty"`

	// SortBy Field to sort by
	SortBy *ListFilesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortOrder Sort order
	SortOrder *ListFilesParamsSortOrder `form:"sort_order,omitempty" json:"sort_order,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListFilesParamsSortBy defines parameters for ListFiles.
type ListFilesParamsSortBy string

// ListFilesParamsSortOrder defines parameters for ListFiles.
type ListFilesParamsSortOrder string

// ListFoldersParams defines parameters for ListFolders.
type ListFoldersParams struct {
	// Keyword Search keyword for folder name
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// ParentId Filter by parent folder ID (omit for root folders)
	ParentId *int `form:"parent_id,omitempty" json:"parent_id,omitempty"`

	// TagIds Filter by tag IDs (comma-separated)
	TagIds *string `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetFolderTreeParams defines parameters for GetFolderTree.
type GetFolderTreeParams struct {
	// ParentId Start from this parent folder (omit for full tree from root)
	ParentId *int `form:"parent_id,omitempty" json:"parent_id,omitempty"`
}

// SearchFilesParams defines parameters for SearchFiles.
type SearchFilesParams struct {
	// Q Search query
	Q string `form:"q" json:"q"`

	// Type Search type
	Type *SearchFilesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// FolderId Limit search to a folder
	FolderId *int `form:"folder_id,omitempty" json:"folder_id,omitempty"`

	// FileType Filter by file type
	FileType *FileType `form:"file_type,omitempty" json:"file_type,omitempty"`

	// TagIds Filter by tag IDs (comma-separated)
	TagIds *string `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// SearchFilesParamsType defines parameters for SearchFiles.
type SearchFilesParamsType string

// ListTagsParams defines parameters for ListTags.
type ListTagsParams struct {
	// Keyword Search keyword for tag name
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// UploadFileMultipartBody defines parameters for UploadFile.
type UploadFileMultipartBody struct {
	// File File to upload
	File openapi_types.File `json:"file"`
}

// GetPresignedURLParams defines parameters for GetPresignedURL.
type GetPresignedURLParams struct {
	// Filename Name of the file to upload
	Filename string `form:"filename" json:"filename"`

	// ContentType MIME type of the file
	ContentType *string `form:"content_type,omitempty" json:"content_type,omitempty"`
}

// CreateFileJSONRequestBody defines body for CreateFile for application/json ContentType.
type CreateFileJSONRequestBody = CreateFileRequest

// BatchDownloadFilesJSONRequestBody defines body for BatchDownloadFiles for application/json ContentType.
type BatchDownloadFilesJSONRequestBody = BatchDownloadRequest

// MoveFilesJSONRequestBody defines body for MoveFiles for application/json ContentType.
type MoveFilesJSONRequestBody = MoveFilesRequest

// UpdateFileJSONRequestBody defines body for UpdateFile for application/json ContentType.
type UpdateFileJSONRequestBody = UpdateFileRequest

// RemoveTagsFromFileJSONRequestBody defines body for RemoveTagsFromFile for application/json ContentType.
type RemoveTagsFromFileJSONRequestBody = TagIdsRequest

// AddTagsToFileJSONRequestBody defines body for AddTagsToFile for application/json ContentType.
type AddTagsToFileJSONRequestBody = TagIdsRequest

// CreateFolderJSONRequestBody defines body for CreateFolder for application/json ContentType.
type CreateFolderJSONRequestBody = CreateFolderRequest

// UpdateFolderJSONRequestBody defines body for UpdateFolder for application/json ContentType.
type UpdateFolderJSONRequestBody = UpdateFolderRequest

// MoveFolderJSONRequestBody defines body for MoveFolder for application/json ContentType.
type MoveFolderJSONRequestBody = MoveFolderRequest

// RemoveTagsFromFolderJSONRequestBody defines body for RemoveTagsFromFolder for application/json ContentType.
type RemoveTagsFromFolderJSONRequestBody = TagIdsRequest

// AddTagsToFolderJSONRequestBody defines body for AddTagsToFolder for application/json ContentType.
type AddTagsToFolderJSONRequestBody = TagIdsRequest

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = CreateTagRequest

// UpdateTagJSONRequestBody defines body for UpdateTag for application/json ContentType.
type UpdateTagJSONRequestBody = UpdateTagRequest

// UploadFileMultipartRequestBody defines body for UploadFile for multipart/form-data ContentType.
type UploadFileMultipartRequestBody UploadFileMultipartBody

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
