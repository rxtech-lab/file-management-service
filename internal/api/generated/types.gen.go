// Package generated provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package generated

import (
	"bytes"
	"compress/gzip"
	"encoding/base64"
	"fmt"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	BearerAuthScopes = "BearerAuth.Scopes"
)

// Defines values for FileType.
const (
	Document FileType = "document"
	Invoice  FileType = "invoice"
	Music    FileType = "music"
	Photo    FileType = "photo"
	Video    FileType = "video"
)

// Defines values for ProcessingStatus.
const (
	Completed  ProcessingStatus = "completed"
	Failed     ProcessingStatus = "failed"
	Pending    ProcessingStatus = "pending"
	Processing ProcessingStatus = "processing"
)

// Defines values for ListFilesParamsSortBy.
const (
	CreatedAt ListFilesParamsSortBy = "created_at"
	Size      ListFilesParamsSortBy = "size"
	Title     ListFilesParamsSortBy = "title"
	UpdatedAt ListFilesParamsSortBy = "updated_at"
)

// Defines values for ListFilesParamsSortOrder.
const (
	Asc  ListFilesParamsSortOrder = "asc"
	Desc ListFilesParamsSortOrder = "desc"
)

// Defines values for SearchFilesParamsType.
const (
	Fulltext SearchFilesParamsType = "fulltext"
	Hybrid   SearchFilesParamsType = "hybrid"
	Semantic SearchFilesParamsType = "semantic"
)

// BatchDownloadRequest defines model for BatchDownloadRequest.
type BatchDownloadRequest struct {
	// FileIds Array of file IDs to download
	FileIds []int `json:"file_ids"`
}

// CreateFileRequest defines model for CreateFileRequest.
type CreateFileRequest struct {
	FileType         *FileType `json:"file_type,omitempty"`
	FolderId         *int      `json:"folder_id"`
	MimeType         *string   `json:"mime_type,omitempty"`
	OriginalFilename string    `json:"original_filename"`
	S3Key            string    `json:"s3_key"`
	Size             *int64    `json:"size,omitempty"`
	Title            string    `json:"title"`
}

// CreateFolderRequest defines model for CreateFolderRequest.
type CreateFolderRequest struct {
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
	ParentId    *int    `json:"parent_id"`
}

// CreateTagRequest defines model for CreateTagRequest.
type CreateTagRequest struct {
	Color       *string `json:"color,omitempty"`
	Description *string `json:"description,omitempty"`
	Name        string  `json:"name"`
}

// Error defines model for Error.
type Error struct {
	// Error Error message
	Error string `json:"error"`
}

// File defines model for File.
type File struct {
	// Content Parsed text content
	Content          *string          `json:"content,omitempty"`
	CreatedAt        time.Time        `json:"created_at"`
	FileType         FileType         `json:"file_type"`
	Folder           *Folder          `json:"folder,omitempty"`
	FolderId         *int             `json:"folder_id"`
	HasEmbedding     bool             `json:"has_embedding"`
	Id               int              `json:"id"`
	MimeType         *string          `json:"mime_type,omitempty"`
	OriginalFilename string           `json:"original_filename"`
	ProcessingError  *string          `json:"processing_error,omitempty"`
	ProcessingStatus ProcessingStatus `json:"processing_status"`
	S3Key            string           `json:"s3_key"`
	Size             *int64           `json:"size,omitempty"`
	Summary          *string          `json:"summary,omitempty"`
	Tags             *[]Tag           `json:"tags,omitempty"`
	Title            string           `json:"title"`
	UpdatedAt        time.Time        `json:"updated_at"`
	UserId           string           `json:"user_id"`
}

// FileDownloadResponse defines model for FileDownloadResponse.
type FileDownloadResponse struct {
	DownloadUrl string    `json:"download_url"`
	ExpiresAt   time.Time `json:"expires_at"`
	Filename    string    `json:"filename"`
	Key         string    `json:"key"`
}

// FileListResponse defines model for FileListResponse.
type FileListResponse struct {
	Data   []File `json:"data"`
	Limit  int    `json:"limit"`
	Offset int    `json:"offset"`
	Total  int    `json:"total"`
}

// FileType defines model for FileType.
type FileType string

// Folder defines model for Folder.
type Folder struct {
	Children    *[]Folder `json:"children,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          int       `json:"id"`
	Name        string    `json:"name"`
	ParentId    *int      `json:"parent_id"`
	Tags        *[]Tag    `json:"tags,omitempty"`
	UpdatedAt   time.Time `json:"updated_at"`
	UserId      string    `json:"user_id"`
}

// FolderListResponse defines model for FolderListResponse.
type FolderListResponse struct {
	Data   []Folder `json:"data"`
	Limit  int      `json:"limit"`
	Offset int      `json:"offset"`
	Total  int      `json:"total"`
}

// FolderTree defines model for FolderTree.
type FolderTree struct {
	Children *[]FolderTree `json:"children,omitempty"`
	Id       int           `json:"id"`
	Name     string        `json:"name"`
	ParentId *int          `json:"parent_id"`
}

// MoveFilesRequest defines model for MoveFilesRequest.
type MoveFilesRequest struct {
	FileIds []int `json:"file_ids"`

	// FolderId Target folder ID (null for root)
	FolderId *int `json:"folder_id"`
}

// MoveFolderRequest defines model for MoveFolderRequest.
type MoveFolderRequest struct {
	// ParentId New parent folder ID (null for root)
	ParentId *int `json:"parent_id"`
}

// PresignedURLResponse defines model for PresignedURLResponse.
type PresignedURLResponse struct {
	ContentType string `json:"content_type"`
	Key         string `json:"key"`
	UploadUrl   string `json:"upload_url"`
}

// ProcessingStatus defines model for ProcessingStatus.
type ProcessingStatus string

// SearchResponse defines model for SearchResponse.
type SearchResponse struct {
	Data       []SearchResult `json:"data"`
	Query      string         `json:"query"`
	SearchType string         `json:"search_type"`
	Total      int            `json:"total"`
}

// SearchResult defines model for SearchResult.
type SearchResult struct {
	File    File    `json:"file"`
	Score   float64 `json:"score"`
	Snippet *string `json:"snippet,omitempty"`
}

// Tag defines model for Tag.
type Tag struct {
	// Color Hex color code (e.g.,
	Color       *string   `json:"color,omitempty"`
	CreatedAt   time.Time `json:"created_at"`
	Description *string   `json:"description,omitempty"`
	Id          int       `json:"id"`
	Name        string    `json:"name"`
	UpdatedAt   time.Time `json:"updated_at"`
	UserId      string    `json:"user_id"`
}

// TagIdsRequest defines model for TagIdsRequest.
type TagIdsRequest struct {
	TagIds []int `json:"tag_ids"`
}

// TagListResponse defines model for TagListResponse.
type TagListResponse struct {
	Data   []Tag `json:"data"`
	Limit  int   `json:"limit"`
	Offset int   `json:"offset"`
	Total  int   `json:"total"`
}

// UpdateFileRequest defines model for UpdateFileRequest.
type UpdateFileRequest struct {
	FileType *FileType `json:"file_type,omitempty"`
	FolderId *int      `json:"folder_id"`
	Summary  *string   `json:"summary,omitempty"`
	Title    *string   `json:"title,omitempty"`
}

// UpdateFolderRequest defines model for UpdateFolderRequest.
type UpdateFolderRequest struct {
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// UpdateTagRequest defines model for UpdateTagRequest.
type UpdateTagRequest struct {
	Color       *string `json:"color,omitempty"`
	Description *string `json:"description,omitempty"`
	Name        *string `json:"name,omitempty"`
}

// UploadResponse defines model for UploadResponse.
type UploadResponse struct {
	ContentType string  `json:"content_type"`
	DownloadUrl *string `json:"download_url,omitempty"`
	Filename    string  `json:"filename"`

	// Key S3 object key
	Key  string `json:"key"`
	Size int    `json:"size"`
}

// FileId defines model for FileId.
type FileId = int

// FolderId defines model for FolderId.
type FolderId = int

// Limit defines model for Limit.
type Limit = int

// Offset defines model for Offset.
type Offset = int

// TagId defines model for TagId.
type TagId = int

// BadRequest defines model for BadRequest.
type BadRequest = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// ListFilesParams defines parameters for ListFiles.
type ListFilesParams struct {
	// Keyword Search keyword for title, summary, or content
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// FolderId Filter by folder ID
	FolderId *int `form:"folder_id,omitempty" json:"folder_id,omitempty"`

	// FileType Filter by file type
	FileType *FileType `form:"file_type,omitempty" json:"file_type,omitempty"`

	// TagIds Filter by tag IDs (comma-separated)
	TagIds *string `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`

	// Status Filter by processing status
	Status *ProcessingStatus `form:"status,omitempty" json:"status,omitempty"`

	// SortBy Field to sort by
	SortBy *ListFilesParamsSortBy `form:"sort_by,omitempty" json:"sort_by,omitempty"`

	// SortOrder Sort order
	SortOrder *ListFilesParamsSortOrder `form:"sort_order,omitempty" json:"sort_order,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// ListFilesParamsSortBy defines parameters for ListFiles.
type ListFilesParamsSortBy string

// ListFilesParamsSortOrder defines parameters for ListFiles.
type ListFilesParamsSortOrder string

// ListFoldersParams defines parameters for ListFolders.
type ListFoldersParams struct {
	// Keyword Search keyword for folder name
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// ParentId Filter by parent folder ID (omit for root folders)
	ParentId *int `form:"parent_id,omitempty" json:"parent_id,omitempty"`

	// TagIds Filter by tag IDs (comma-separated)
	TagIds *string `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetFolderTreeParams defines parameters for GetFolderTree.
type GetFolderTreeParams struct {
	// ParentId Start from this parent folder (omit for full tree from root)
	ParentId *int `form:"parent_id,omitempty" json:"parent_id,omitempty"`
}

// SearchFilesParams defines parameters for SearchFiles.
type SearchFilesParams struct {
	// Q Search query
	Q string `form:"q" json:"q"`

	// Type Search type
	Type *SearchFilesParamsType `form:"type,omitempty" json:"type,omitempty"`

	// FolderId Limit search to a folder
	FolderId *int `form:"folder_id,omitempty" json:"folder_id,omitempty"`

	// FileType Filter by file type
	FileType *FileType `form:"file_type,omitempty" json:"file_type,omitempty"`

	// TagIds Filter by tag IDs (comma-separated)
	TagIds *string `form:"tag_ids,omitempty" json:"tag_ids,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// SearchFilesParamsType defines parameters for SearchFiles.
type SearchFilesParamsType string

// ListTagsParams defines parameters for ListTags.
type ListTagsParams struct {
	// Keyword Search keyword for tag name
	Keyword *string `form:"keyword,omitempty" json:"keyword,omitempty"`

	// Limit Maximum number of items to return
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Number of items to skip
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// UploadFileMultipartBody defines parameters for UploadFile.
type UploadFileMultipartBody struct {
	// File File to upload
	File openapi_types.File `json:"file"`
}

// GetPresignedURLParams defines parameters for GetPresignedURL.
type GetPresignedURLParams struct {
	// Filename Name of the file to upload
	Filename string `form:"filename" json:"filename"`

	// ContentType MIME type of the file
	ContentType *string `form:"content_type,omitempty" json:"content_type,omitempty"`
}

// CreateFileJSONRequestBody defines body for CreateFile for application/json ContentType.
type CreateFileJSONRequestBody = CreateFileRequest

// BatchDownloadFilesJSONRequestBody defines body for BatchDownloadFiles for application/json ContentType.
type BatchDownloadFilesJSONRequestBody = BatchDownloadRequest

// MoveFilesJSONRequestBody defines body for MoveFiles for application/json ContentType.
type MoveFilesJSONRequestBody = MoveFilesRequest

// UpdateFileJSONRequestBody defines body for UpdateFile for application/json ContentType.
type UpdateFileJSONRequestBody = UpdateFileRequest

// RemoveTagsFromFileJSONRequestBody defines body for RemoveTagsFromFile for application/json ContentType.
type RemoveTagsFromFileJSONRequestBody = TagIdsRequest

// AddTagsToFileJSONRequestBody defines body for AddTagsToFile for application/json ContentType.
type AddTagsToFileJSONRequestBody = TagIdsRequest

// CreateFolderJSONRequestBody defines body for CreateFolder for application/json ContentType.
type CreateFolderJSONRequestBody = CreateFolderRequest

// UpdateFolderJSONRequestBody defines body for UpdateFolder for application/json ContentType.
type UpdateFolderJSONRequestBody = UpdateFolderRequest

// MoveFolderJSONRequestBody defines body for MoveFolder for application/json ContentType.
type MoveFolderJSONRequestBody = MoveFolderRequest

// RemoveTagsFromFolderJSONRequestBody defines body for RemoveTagsFromFolder for application/json ContentType.
type RemoveTagsFromFolderJSONRequestBody = TagIdsRequest

// AddTagsToFolderJSONRequestBody defines body for AddTagsToFolder for application/json ContentType.
type AddTagsToFolderJSONRequestBody = TagIdsRequest

// CreateTagJSONRequestBody defines body for CreateTag for application/json ContentType.
type CreateTagJSONRequestBody = CreateTagRequest

// UpdateTagJSONRequestBody defines body for UpdateTag for application/json ContentType.
type UpdateTagJSONRequestBody = UpdateTagRequest

// UploadFileMultipartRequestBody defines body for UploadFile for multipart/form-data ContentType.
type UploadFileMultipartRequestBody UploadFileMultipartBody

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"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",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
